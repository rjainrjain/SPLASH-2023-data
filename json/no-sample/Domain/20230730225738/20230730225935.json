{"date":"2023-07-31T02:59:35.745Z","prompt":{"systemInst":"You are a code generator that is generating a new program in the Substance programming language, which draws from the Domain programming language program also given below. To write comments, begin with `--`. Return only the Substance program; do not explain your reasoning whatsoever.\n\n","penroseContext":"We have been working on a platform called Penrose for authoring mathematical diagrams. The system involves a family of 3 domain specific languages: Substance (for specifying the mathematical objects and the relationships between those objects, Style (for mapping the mathematical objects to shapes and mathematical relationships to layout constraints and objectives), and Domain (for specifying the types of mathematical objects and relationships; this is a meta-language or schema language). Those three programs are used to synthesize a layout problem which we then solve to create a corresponding diagram.\n\n","domain":"-- ~~~~~~~~~~~~~~~~ TYPES ~~~~~~~~~~~~~~~~\ntype Shape\ntype Point <: Shape -- This type describes a point. Example usage: \n-- Point A, B, C\n-- AutoLabel A, B, C\ntype Linelike <: Shape -- This type describes a plane. Example usage: \n-- Plane p\n-- AutoLabel p\ntype Ray <: Linelike -- This type describes a ray. See construction of a ray below.\ntype Line <: Linelike -- This type describes a line. See construction of a line below.\ntype Segment <: Linelike -- This type describes a line segment. See construction of a line segment below.\n\ntype Angle <: Shape -- This type describes an angle. See construction of an angle below.\n\ntype Triangle <: Shape -- This type describes a triangle. See construction of a triangle below.\ntype Quadrilateral <: Shape -- This type describes a quadrilateral. See construction of a quadrilateral below.\ntype Rectangle <: Quadrilateral -- This type describes a rectangle. See construction of a rectangle below.\ntype Circle <: Shape -- This type describes a circle. See construction of a circle below.\n\ntype Plane <: Shape -- This type describes a plane. Example usage: \n-- Plane p\n-- AutoLabel p\n\n-- ~~~~~~~~~~~~~~~~ CONSTRUCTORS ~~~~~~~~~~~~~~~~\n-- Lines and Points\nconstructor Segment(Point p, Point q) -- This constructor creates a line segment from two points. Example usage: \n-- Point A, B\n-- Segment AB := Segment(A, B)\n-- AutoLabel A, B\nconstructor Ray(Point base, Point direction) -- This constructor creates a ray from two points, a base and a direction point. Example usage: \n-- Point A, B\n-- Ray rayAB := Ray(A, B)\n-- AutoLabel A, B\nconstructor Line(Point p, Point q) -- This constructor creates a line from two points. Example usage: \n-- Point A, B\n-- Line lineAB := Line(A, B)\n-- AutoLabel A, B\nconstructor Midpoint(Linelike l) -> Point -- This constructor creates a point as the midpoint of a line. Example usage: \n-- Point A, B\n-- Segment segmentAB\n-- segmentAB := Segment(A, B)\n-- Point midpointAB := Midpoint(AB)\n-- AutoLabel A, B, midpointAB\n\n-- Angles\nconstructor InteriorAngle(Point p, Point q, Point r) -> Angle -- This constructor creates an angle from three points. Example usage: \n-- Point A, B, C\n-- Angle angleABC := InteriorAngle(A, B, C)\n-- AutoLabel A, B, C\n\n-- Polygons/Shapes\nconstructor Triangle(Point p, Point q, Point r) -- This constructor creates a triangle from three points. Example usage: Point A, B, C\n-- Triangle triangleABC := Triangle(A, B, C)\n-- AutoLabel A, B, C\nconstructor Rectangle(Point p, Point q, Point r, Point s) -- This constructor creates a rectangle from four points. Example usage: \n-- Point A, B, C, D\n-- Rectangle rectangleABCD := Rectangle(A, B, C, D)\n-- AutoLabel A, B, C, D\nconstructor Quadrilateral(Point p, Point q, Point r, Point s) -- This function creates a quadrilateral from four points. Example usage: \n-- Point A, B, C, D\n-- Quadrilateral quadrilateralABCD := Quadrilateral(A, B, C, D)\n-- AutoLabel A, B, C, D\nconstructor CircleR(Point center, Point radius) -> Circle -- This constructor creates a circle from a center point and a radius point. Example usage: \n-- Point A, B\n-- Circle circleAB := CircleR(A, B)\n-- AutoLabel A, B\n-- constructor CircleD(Point diam1, Point diam2) -> Circle  -- TODO can be reimplemented when #621 is resolved\n\n-- ~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~\n-- Lines and Points\nfunction Bisector(Angle) -> Ray -- This function creates a ray as the angle bisector of an angle. Example usage: \n-- Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Ray bisectorABC := Bisector(angleABC)\n-- AutoLabel A, B, C, bisectorABC\nfunction PerpendicularBisector(Segment, Point) -> Segment -- This function creates a perpendicular bisector from a line segment. Example usage: \n-- Point A, B, C\n-- Segment AB\n-- AB := Segment(A, B)\n-- Segment perpendicularBisectorAB := PerpendicularBisector(AB, C)\n-- AutoLabel A, B, C\nfunction PerpendicularBisectorLabelPts(Segment, Point, Point) -> Segment -- This function creates a perpendicular bisector from a segment to bisect, a base point, and a direction point. Example usage: \n-- Point A, B, C, D, d\n-- Segment AB, CD\n-- AB := Segment(A, B)\n-- CD := Segment(C, D)\n-- PerpendicularBisectorLabelPts(AB, C, d)\n-- AutoLabel A, B, C, D, d\n\n-- Polygons/Shapes\nfunction MidSegment(Triangle, Point, Point) -> Segment -- This function creates a midsegment from a triangle and two points on the triangle. Example usage: \n-- Point A, B, C, D, E\n-- Triangle triangleABC := Triangle(A, B, C)\n-- Segment midsegmentDE := MidSegment(triangleABC, D, E)\n-- AutoLabel A, B, C, D, E\nfunction Radius(Circle c, Point p) -> Segment -- This function creates a radius from a circle and a point on the circle. Example usage: \n-- Point A, B\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- Segment radiusAB := Radius(circleAB, B)\n-- AutoLabel A, B\nfunction Chord(Circle c, Point p, Point q) -> Segment -- This function creates a chord from a circle and two points on the circle. Example usage: \n-- Point A, B, C\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- Segment chordAC := Chord(circleAB, A, C)\n-- AutoLabel A, B, C\nfunction Diameter(Circle c, Point p, Point q) -> Segment -- This function creates a diameter from a circle and two points. Example usage: \n-- Point A, B\n-- Circle circleAB\n-- \n-- Segment diameterAC := Diameter(circleAB, A, B)\n-- AutoLabel A, B\n\n-- Unimplemented\n-- function Sum(Angle, Angle) -> Angle\n-- function Intersection(Linelike, Linelike) -> Point\n-- function Altitude(Triangle, Angle) -> Segment\n-- function Endpoint(Segment) -> Point\n\n-- ~~~~~~~~~~~~~~~~ PREDICATES ~~~~~~~~~~~~~~~~\n-- Lines and Points\npredicate On(Point, Linelike) -- This predicate makes a point be on a line. Example use: Point A, B\n-- Line lineAB\n-- lineAB := Line(A, B)\n-- On(A, lineAB)\n-- AutoLabel A, B\npredicate In(Point, Plane) -- This predicate makes a point be in a plane. Example use: Point A, B\n-- Plane planeAB\n-- planeAB := Plane(A, B)\n-- In(A, planeAB)\n-- AutoLabel A, B\npredicate Midpoint(Linelike, Point) -- This predicate makes a point be the midpoint of a line. Example use: Point A, B, C\n-- Segment segmentAB\n-- segmentAB := Segment(A, B)\n-- Midpoint(segmentAB, C)\n-- AutoLabel A, B, C\npredicate Collinear(Point, Point, Point) -- This predicate makes three points collinear. Example use: Point A, B, C\n-- Segment AB, BC\n-- AB := Segment(A, B)\n-- BC := Segment(B, C)\n-- Collinear(A, B, C)\npredicate ParallelMarker1(Linelike, Linelike) -- This predicate marks two lines parallel. Only use if Parallel precedes it. Example use: Point A, B, C, D\n-- Line lineAB, lineCD\n-- lineAB := Line(A, B)\n-- lineCD := Line(C, D)\n-- Parallel(lineAB, lineCD)\n-- ParallelMarker1(lineAB, lineCD)\n-- AutoLabel A, B, C, D\npredicate EqualLengthMarker(Linelike, Linelike) -- This predicate only marks two segments with a tick indicating that they have equal length. Only use if EqualLength precedes it. Example use: Point A, B, C, D\n-- Segment segmentAB, segmentCD\n-- segmentAB := Segment(A, B)\n-- segmentCD := Segment(C, D)\n-- EqualLength(segmentAB, segmentCD)\n-- EqualLengthMarker(segmentAB, segmentCD)\n-- AutoLabel A, B, C, D\npredicate EqualLength(Linelike, Linelike) -- This predicate makes two segments have equal length. Example use: Point A, B, C, D\n-- Segment segmentAB, segmentCD\n-- segmentAB := Segment(A, B)\n-- segmentCD := Segment(C, D)\n-- EqualLength(segmentAB, segmentCD)\n-- AutoLabel A, B, C, D\npredicate Parallel(Linelike, Linelike) -- This predicate makes two lines parallel. Example use: Point A, B, C, D\n-- Line lineAB, lineCD\n-- lineAB := Line(A, B)\n-- lineCD := Line(C, D)\n-- Parallel(lineAB, lineCD)\n-- AutoLabel A, B, C, D\n\n-- Angles\npredicate Acute(Angle) -- This predicate makes an angle acute. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Acute(angleABC)\n-- AutoLabel A, B, C\npredicate Obtuse(Angle) -- This predicate makes an angle obtuse. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Obtuse(angleABC)\n-- AutoLabel A, B, C\npredicate RightMarked(Angle) -- This predicate makes an angle right and marks it with a square. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- RightMarked(angleABC)\n-- AutoLabel A, B, C\npredicate RightUnmarked(Angle) -- This predicate makes an angle right and does not mark it with a square. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- RightUnmarked(angleABC)\n-- AutoLabel A, B, C\npredicate AngleBisector(Angle, Linelike) -- This predicate makes a ray be the angle bisector of an angle. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Ray rayABC\n-- rayABC := Ray(A, B)\n-- AngleBisector(angleABC, rayABC)\n-- AutoLabel A, B, C\npredicate EqualAngleMarker(Angle, Angle) -- This predicate only marks two angles with a tick indicating that they have equal measure. Only use if EqualAngle precedes it. Example use: Point A, B, C, D, E, F\n-- Angle angleABC, angleDEF\n-- angleABC := InteriorAngle(A, B, C)\n-- angleDEF := InteriorAngle(D, E, F)\n-- EqualAngle(angleABC, angleDEF)\n-- EqualAngleMarker(angleABC, angleDEF)\n-- AutoLabel A, B, C, D, E, F\npredicate EqualAngle(Angle, Angle) -- This predicate makes two angles have equal measure. Example use: Point A, B, C, D, E, F\n-- Angle angleABC, angleDEF\n-- angleABC := InteriorAngle(A, B, C)\n-- angleDEF := InteriorAngle(D, E, F)\n-- EqualAngle(angleABC, angleDEF)\n-- AutoLabel A, B, C, D, E, F\n\n-- Polygons/Shapes\npredicate Parallelogram(Quadrilateral) -- This predicate makes a quadrilateral a parallelogram. Example use: Point A, B, C, D\n-- Quadrilateral quadrilateralABCD\n-- quadrilateralABCD := Quadrilateral(A, B, C, D)\n-- Parallelogram(quadrilateralABCD)\n-- AutoLabel A, B, C, D\npredicate OnCircle(Circle, Point) -- This predicate makes a point be on a circle. Example use: Point A, B, C\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- OnCircle(circleAB, C)\n-- AutoLabel A, B, C\npredicate CircleCenter(Circle, Point) -- Do not use.\npredicate Incenter(Point, Triangle) -- This predicate makes a point be the incenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Incenter(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Orthocenter(Point, Triangle) -- This predicate makes a point be the orthocenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Orthocenter(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Centroid(Point, Triangle) -- This predicate makes a point be the centroid of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Centroid(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Circumcenter(Point, Triangle) -- This predicate makes a point be the circumcenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Circumcenter(D, triangleABC)\n-- AutoLabel A, B, C, D\n\n-- notation \"{p, q}\" ~ \"Segment(p, q)\"\n-- notation \"{p, q, r}\" ~ \"Triangle(p, q, r)\"\n-- notation \"{p, q, r, s}\" ~ \"Rectangle(p, q, r, s)\"\n-- notation \"∠(p, q, r)\" ~ \"InteriorAngle(p, q, r)\"\n\n","descriptionPrelude":"Given the context above, can you generate a new Substance program which describes the following:","description":"a line segment which has a line segment at its midpoint forming an acute and an obtuse angle?","finalInst":"To write comments, begin with `--`. Return only the Substance program; do not explain your reasoning whatsoever. Avoid duplicate naming of variables.","prompt":"You are a code generator that is generating a new program in the Substance programming language, which draws from the Domain programming language program also given below. To write comments, begin with `--`. Return only the Substance program; do not explain your reasoning whatsoever.\n\nWe have been working on a platform called Penrose for authoring mathematical diagrams. The system involves a family of 3 domain specific languages: Substance (for specifying the mathematical objects and the relationships between those objects, Style (for mapping the mathematical objects to shapes and mathematical relationships to layout constraints and objectives), and Domain (for specifying the types of mathematical objects and relationships; this is a meta-language or schema language). Those three programs are used to synthesize a layout problem which we then solve to create a corresponding diagram.\n\nHere is a Domain program which would inform a Substance program:\n```\n-- ~~~~~~~~~~~~~~~~ TYPES ~~~~~~~~~~~~~~~~\ntype Shape\ntype Point <: Shape -- This type describes a point. Example usage: \n-- Point A, B, C\n-- AutoLabel A, B, C\ntype Linelike <: Shape -- This type describes a plane. Example usage: \n-- Plane p\n-- AutoLabel p\ntype Ray <: Linelike -- This type describes a ray. See construction of a ray below.\ntype Line <: Linelike -- This type describes a line. See construction of a line below.\ntype Segment <: Linelike -- This type describes a line segment. See construction of a line segment below.\n\ntype Angle <: Shape -- This type describes an angle. See construction of an angle below.\n\ntype Triangle <: Shape -- This type describes a triangle. See construction of a triangle below.\ntype Quadrilateral <: Shape -- This type describes a quadrilateral. See construction of a quadrilateral below.\ntype Rectangle <: Quadrilateral -- This type describes a rectangle. See construction of a rectangle below.\ntype Circle <: Shape -- This type describes a circle. See construction of a circle below.\n\ntype Plane <: Shape -- This type describes a plane. Example usage: \n-- Plane p\n-- AutoLabel p\n\n-- ~~~~~~~~~~~~~~~~ CONSTRUCTORS ~~~~~~~~~~~~~~~~\n-- Lines and Points\nconstructor Segment(Point p, Point q) -- This constructor creates a line segment from two points. Example usage: \n-- Point A, B\n-- Segment AB := Segment(A, B)\n-- AutoLabel A, B\nconstructor Ray(Point base, Point direction) -- This constructor creates a ray from two points, a base and a direction point. Example usage: \n-- Point A, B\n-- Ray rayAB := Ray(A, B)\n-- AutoLabel A, B\nconstructor Line(Point p, Point q) -- This constructor creates a line from two points. Example usage: \n-- Point A, B\n-- Line lineAB := Line(A, B)\n-- AutoLabel A, B\nconstructor Midpoint(Linelike l) -> Point -- This constructor creates a point as the midpoint of a line. Example usage: \n-- Point A, B\n-- Segment segmentAB\n-- segmentAB := Segment(A, B)\n-- Point midpointAB := Midpoint(AB)\n-- AutoLabel A, B, midpointAB\n\n-- Angles\nconstructor InteriorAngle(Point p, Point q, Point r) -> Angle -- This constructor creates an angle from three points. Example usage: \n-- Point A, B, C\n-- Angle angleABC := InteriorAngle(A, B, C)\n-- AutoLabel A, B, C\n\n-- Polygons/Shapes\nconstructor Triangle(Point p, Point q, Point r) -- This constructor creates a triangle from three points. Example usage: Point A, B, C\n-- Triangle triangleABC := Triangle(A, B, C)\n-- AutoLabel A, B, C\nconstructor Rectangle(Point p, Point q, Point r, Point s) -- This constructor creates a rectangle from four points. Example usage: \n-- Point A, B, C, D\n-- Rectangle rectangleABCD := Rectangle(A, B, C, D)\n-- AutoLabel A, B, C, D\nconstructor Quadrilateral(Point p, Point q, Point r, Point s) -- This function creates a quadrilateral from four points. Example usage: \n-- Point A, B, C, D\n-- Quadrilateral quadrilateralABCD := Quadrilateral(A, B, C, D)\n-- AutoLabel A, B, C, D\nconstructor CircleR(Point center, Point radius) -> Circle -- This constructor creates a circle from a center point and a radius point. Example usage: \n-- Point A, B\n-- Circle circleAB := CircleR(A, B)\n-- AutoLabel A, B\n-- constructor CircleD(Point diam1, Point diam2) -> Circle  -- TODO can be reimplemented when #621 is resolved\n\n-- ~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~\n-- Lines and Points\nfunction Bisector(Angle) -> Ray -- This function creates a ray as the angle bisector of an angle. Example usage: \n-- Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Ray bisectorABC := Bisector(angleABC)\n-- AutoLabel A, B, C, bisectorABC\nfunction PerpendicularBisector(Segment, Point) -> Segment -- This function creates a perpendicular bisector from a line segment. Example usage: \n-- Point A, B, C\n-- Segment AB\n-- AB := Segment(A, B)\n-- Segment perpendicularBisectorAB := PerpendicularBisector(AB, C)\n-- AutoLabel A, B, C\nfunction PerpendicularBisectorLabelPts(Segment, Point, Point) -> Segment -- This function creates a perpendicular bisector from a segment to bisect, a base point, and a direction point. Example usage: \n-- Point A, B, C, D, d\n-- Segment AB, CD\n-- AB := Segment(A, B)\n-- CD := Segment(C, D)\n-- PerpendicularBisectorLabelPts(AB, C, d)\n-- AutoLabel A, B, C, D, d\n\n-- Polygons/Shapes\nfunction MidSegment(Triangle, Point, Point) -> Segment -- This function creates a midsegment from a triangle and two points on the triangle. Example usage: \n-- Point A, B, C, D, E\n-- Triangle triangleABC := Triangle(A, B, C)\n-- Segment midsegmentDE := MidSegment(triangleABC, D, E)\n-- AutoLabel A, B, C, D, E\nfunction Radius(Circle c, Point p) -> Segment -- This function creates a radius from a circle and a point on the circle. Example usage: \n-- Point A, B\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- Segment radiusAB := Radius(circleAB, B)\n-- AutoLabel A, B\nfunction Chord(Circle c, Point p, Point q) -> Segment -- This function creates a chord from a circle and two points on the circle. Example usage: \n-- Point A, B, C\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- Segment chordAC := Chord(circleAB, A, C)\n-- AutoLabel A, B, C\nfunction Diameter(Circle c, Point p, Point q) -> Segment -- This function creates a diameter from a circle and two points. Example usage: \n-- Point A, B\n-- Circle circleAB\n-- \n-- Segment diameterAC := Diameter(circleAB, A, B)\n-- AutoLabel A, B\n\n-- Unimplemented\n-- function Sum(Angle, Angle) -> Angle\n-- function Intersection(Linelike, Linelike) -> Point\n-- function Altitude(Triangle, Angle) -> Segment\n-- function Endpoint(Segment) -> Point\n\n-- ~~~~~~~~~~~~~~~~ PREDICATES ~~~~~~~~~~~~~~~~\n-- Lines and Points\npredicate On(Point, Linelike) -- This predicate makes a point be on a line. Example use: Point A, B\n-- Line lineAB\n-- lineAB := Line(A, B)\n-- On(A, lineAB)\n-- AutoLabel A, B\npredicate In(Point, Plane) -- This predicate makes a point be in a plane. Example use: Point A, B\n-- Plane planeAB\n-- planeAB := Plane(A, B)\n-- In(A, planeAB)\n-- AutoLabel A, B\npredicate Midpoint(Linelike, Point) -- This predicate makes a point be the midpoint of a line. Example use: Point A, B, C\n-- Segment segmentAB\n-- segmentAB := Segment(A, B)\n-- Midpoint(segmentAB, C)\n-- AutoLabel A, B, C\npredicate Collinear(Point, Point, Point) -- This predicate makes three points collinear. Example use: Point A, B, C\n-- Segment AB, BC\n-- AB := Segment(A, B)\n-- BC := Segment(B, C)\n-- Collinear(A, B, C)\npredicate ParallelMarker1(Linelike, Linelike) -- This predicate marks two lines parallel. Only use if Parallel precedes it. Example use: Point A, B, C, D\n-- Line lineAB, lineCD\n-- lineAB := Line(A, B)\n-- lineCD := Line(C, D)\n-- Parallel(lineAB, lineCD)\n-- ParallelMarker1(lineAB, lineCD)\n-- AutoLabel A, B, C, D\npredicate EqualLengthMarker(Linelike, Linelike) -- This predicate only marks two segments with a tick indicating that they have equal length. Only use if EqualLength precedes it. Example use: Point A, B, C, D\n-- Segment segmentAB, segmentCD\n-- segmentAB := Segment(A, B)\n-- segmentCD := Segment(C, D)\n-- EqualLength(segmentAB, segmentCD)\n-- EqualLengthMarker(segmentAB, segmentCD)\n-- AutoLabel A, B, C, D\npredicate EqualLength(Linelike, Linelike) -- This predicate makes two segments have equal length. Example use: Point A, B, C, D\n-- Segment segmentAB, segmentCD\n-- segmentAB := Segment(A, B)\n-- segmentCD := Segment(C, D)\n-- EqualLength(segmentAB, segmentCD)\n-- AutoLabel A, B, C, D\npredicate Parallel(Linelike, Linelike) -- This predicate makes two lines parallel. Example use: Point A, B, C, D\n-- Line lineAB, lineCD\n-- lineAB := Line(A, B)\n-- lineCD := Line(C, D)\n-- Parallel(lineAB, lineCD)\n-- AutoLabel A, B, C, D\n\n-- Angles\npredicate Acute(Angle) -- This predicate makes an angle acute. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Acute(angleABC)\n-- AutoLabel A, B, C\npredicate Obtuse(Angle) -- This predicate makes an angle obtuse. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Obtuse(angleABC)\n-- AutoLabel A, B, C\npredicate RightMarked(Angle) -- This predicate makes an angle right and marks it with a square. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- RightMarked(angleABC)\n-- AutoLabel A, B, C\npredicate RightUnmarked(Angle) -- This predicate makes an angle right and does not mark it with a square. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- RightUnmarked(angleABC)\n-- AutoLabel A, B, C\npredicate AngleBisector(Angle, Linelike) -- This predicate makes a ray be the angle bisector of an angle. Example use: Point A, B, C\n-- Angle angleABC\n-- angleABC := InteriorAngle(A, B, C)\n-- Ray rayABC\n-- rayABC := Ray(A, B)\n-- AngleBisector(angleABC, rayABC)\n-- AutoLabel A, B, C\npredicate EqualAngleMarker(Angle, Angle) -- This predicate only marks two angles with a tick indicating that they have equal measure. Only use if EqualAngle precedes it. Example use: Point A, B, C, D, E, F\n-- Angle angleABC, angleDEF\n-- angleABC := InteriorAngle(A, B, C)\n-- angleDEF := InteriorAngle(D, E, F)\n-- EqualAngle(angleABC, angleDEF)\n-- EqualAngleMarker(angleABC, angleDEF)\n-- AutoLabel A, B, C, D, E, F\npredicate EqualAngle(Angle, Angle) -- This predicate makes two angles have equal measure. Example use: Point A, B, C, D, E, F\n-- Angle angleABC, angleDEF\n-- angleABC := InteriorAngle(A, B, C)\n-- angleDEF := InteriorAngle(D, E, F)\n-- EqualAngle(angleABC, angleDEF)\n-- AutoLabel A, B, C, D, E, F\n\n-- Polygons/Shapes\npredicate Parallelogram(Quadrilateral) -- This predicate makes a quadrilateral a parallelogram. Example use: Point A, B, C, D\n-- Quadrilateral quadrilateralABCD\n-- quadrilateralABCD := Quadrilateral(A, B, C, D)\n-- Parallelogram(quadrilateralABCD)\n-- AutoLabel A, B, C, D\npredicate OnCircle(Circle, Point) -- This predicate makes a point be on a circle. Example use: Point A, B, C\n-- Circle circleAB\n-- circleAB := CircleR(A, B)\n-- OnCircle(circleAB, C)\n-- AutoLabel A, B, C\npredicate CircleCenter(Circle, Point) -- Do not use.\npredicate Incenter(Point, Triangle) -- This predicate makes a point be the incenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Incenter(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Orthocenter(Point, Triangle) -- This predicate makes a point be the orthocenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Orthocenter(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Centroid(Point, Triangle) -- This predicate makes a point be the centroid of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Centroid(D, triangleABC)\n-- AutoLabel A, B, C, D\npredicate Circumcenter(Point, Triangle) -- This predicate makes a point be the circumcenter of a triangle. Example use: Point A, B, C, D\n-- Triangle triangleABC\n-- triangleABC := Triangle(A, B, C)\n-- Circumcenter(D, triangleABC)\n-- AutoLabel A, B, C, D\n\n-- notation \"{p, q}\" ~ \"Segment(p, q)\"\n-- notation \"{p, q, r}\" ~ \"Triangle(p, q, r)\"\n-- notation \"{p, q, r, s}\" ~ \"Rectangle(p, q, r, s)\"\n-- notation \"∠(p, q, r)\" ~ \"InteriorAngle(p, q, r)\"\n\n\n```\n\nGiven the context above, can you generate a new Substance program which describes the following: a line segment which has a line segment at its midpoint forming an acute and an obtuse angle? \n\nTo write comments, begin with `--`. Return only the Substance program; do not explain your reasoning whatsoever. Avoid duplicate naming of variables.","style":"canvas {\n  width = 500\n  height = 500\n}\n\nColors {\n    -- Keenan palette\n    black = #000000\n    darkpurple = #8c90c1\n    lightpurple = #d0d3e6\n    purple2 = rgba(0.106, 0.122, 0.54, 0.2)\n    verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)\n    purple3 = rgba(0.557, 0.627, 0.769, 1.0)\n    midnightblue = rgba(0.14, 0.16, 0.52, 1.0)\n    none = none()\n}\n\nconst {\n    arrowheadSize = 0.65\n    strokeWidth = 1.75\n    textPadding = 10.0\n    textPadding2 = 25.0\n    repelWeight = 0.7 -- TODO: Reverted from 0.0\n    repelWeight2 = 0.5\n    fontSize = \"20px\"\n    containPadding = 50.0\n    rayLength = 100.0\n    pointRadius = 4.0\n    pointStroke = 0.0\n    thetaRadius = 30.0\n    circleRadius = 150.0\n    labelPadding = 30.0\n    minSegmentLength = 80.0\n    minLineLength = 200.0\n}\n\nlayout = [shape, label]\n\n--Plane\nforall Plane p {\n  width = canvas.width * .8\n  height = canvas.height * .8\n  p.text = Equation {\n    center : ((width / 2.0) - const.textPadding2, (height / 2.0) - const.textPadding2)\n    string : p.label\n    fontSize : const.fontSize\n  }\n\n  -- inner: #f3f4f9, outer: #8e93c4\n  p.icon = Rectangle {\n    -- angle : 0.0\n    -- fillColor : Colors.purple2\n    fillColor : Colors.none -- TODO: arrange angle markers so plane can be opaque\n    strokeColor : Colors.purple3\n    strokeWidth : 2.0\n    center : (0.0, 0.0)\n    width : width\n    height : height\n  }\n\n  p.text above p.icon\n}\n\n--Point\nforall Point p {\n  p.x = ? except label\n  p.y = ? except label\n  p.vec = (p.x, p.y)\n  p.color = Colors.black\n\n  p.icon = Circle {\n    center: p.vec\n    r : const.pointRadius\n    fillColor : Colors.black\n    strokeWidth : 0.0\n    strokeColor : Colors.black\n  }\n\n  p.text = Equation {\n    string : p.label\n    fillColor : Colors.black\n    fontSize : const.fontSize\n    center: (? in label, ? in label)\n    ensureOnCanvas: false\n  }\n  ensure onCanvas(p.text, canvas.width, canvas.height) in label\n  ensure signedDistance(p.text, p.vec) == const.textPadding + const.pointRadius in label\n}\n\n-- default: if `Point` is not on a `Plane`, the point should be below the plane to stay hidden\nforall Point p\nwith Plane P {\n  p.iconOnPlane = ensure disjoint(p.icon, P.icon)\n  p.textOnPlane = ensure disjoint(p.text, P.icon) in label\n}\n\nforall Point p\nwith Plane P\nwhere In(p, P) {\n  -- TODO: the problem is that this ensures the padding is const? Or is > padding okay?\n  -- There's a choice of whether to put padding on the point or the text for containment\n  override p.iconOnPlane = ensure contains(P.icon, p.icon, const.containPadding)\n  override p.textOnPlane = ensure contains(P.icon, p.text) in label\n\n  p.icon above P.icon\n  p.text above P.icon\n}\n\nforall Point p, q, r\nwhere Collinear(p, q, r) {\n  ensure collinearOrdered(p.icon.center, q.icon.center, r.icon.center) \n  encourage notTooClose(p.icon, r.icon, const.repelWeight)\n}\n\nforall Point p\nwith Linelike l\nwhere On(p, l) {\n  ensure signedDistance(l.icon, p.vec) == 0\n}\n\nforall Point p\nwith Linelike l\nwhere On(p, l); p has label {\n  ensure disjoint(l.icon, p.text) in label\n}\n\n--Linelike\nforall Linelike l {\n  l.color = Colors.black\n\n  l.icon = Line {\n    start : (?, ?)\n    end : (?, ?)\n    strokeColor : l.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n}\n\nforall Ray r\nwhere r := Ray(base, direction)\nwith Point base; Point direction {\n  r.start = base.vec\n  r.end = direction.vec\n  r.vec = direction.vec - base.vec\n\n  override r.icon = Line {\n    start : base.icon.center\n    end : ptOnLine(base.vec, direction.vec, norm(r.vec) + 40.)\n    strokeColor : r.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n    endArrowhead : \"straight\"\n    endArrowheadSize: const.arrowheadSize\n  }\n  -- labeling\n  ensure disjoint(r.icon, base.text) in label\n  ensure disjoint(r.icon, direction.text) in label\n}\n\nforall Ray r {\n    r.length = const.rayLength\n}\n\nforall Ray r\nwith Angle theta; Point x; Point y; Point z\nwhere r := Bisector(theta); theta := InteriorAngle(y, x, z) {\n  -- find the vector for the bisector ray\n  xy = normalize(y.vec - x.vec)\n  xz = normalize(z.vec - x.vec)\n  r_vec = xy + xz\n  -- change from generic `Linelike` shape to a specific shape for `Ray`\n  override r.icon = Line {\n    start: x.vec\n    end:  (r.length * normalize(r_vec)) + x.vec\n    strokeWidth : const.strokeWidth\n    strokeColor : Colors.black\n    endArrowhead: \"straight\"\n    endArrowheadSize : const.arrowheadSize\n  }\n  r.icon below x.icon\n}\n\nforall Line l\nwhere l := Line(p, q)\nwith Point p; Point q {\n  l.start = p.vec\n  l.end = q.vec\n  l.vec = q.vec - p.vec\n  override l.icon = Line {\n    start : ptOnLine(p.vec,q.vec, -40.)\n    end : ptOnLine(p.vec, q.vec, norm(l.vec) + 40.)\n    strokeColor : l.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n    endArrowhead : \"straight\"\n    startArrowhead: \"straight\"\n    startArrowheadSize: const.arrowheadSize\n    endArrowheadSize: const.arrowheadSize\n  }\n\n  -- edge case\n  ensure norm(l.vec) > const.minLineLength\n\n  -- labeling\n  ensure disjoint(l.icon, p.text) in label\n  ensure disjoint(l.icon, q.text) in label\n}\n\nforall Linelike l1, l2 -- should this work with rays and lines?\nwhere ParallelMarker1(l1, l2) {\n  l1.tick1 = Path {\n    d : pathFromPoints(\"open\", chevron(l1.icon, 20.))\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n  l2.tick1 = Path {\n    d : pathFromPoints(\"open\", chevron(l2.icon, 20.))\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n}\n\nforall Linelike l1, l2\nwhere Parallel(l1, l2) {\n  -- the dot product of the unit vectors of parallel lines is 1\n  -- HACK: scaling to 10000s for convergence\n  ensure 10000 == dot(normalize(l1.vec), normalize(l2.vec)) * 10000\n}\n--Segment\nforall Segment e\nwhere e := Segment(p, q)\nwith Point p; Point q {\n  e.vec = [q.x - p.x, q.y - p.y]\n  e.start = p.vec\n  e.end = q.vec\n\n  override e.icon = Line {\n    start : p.icon.center\n    end : q.icon.center\n    strokeColor : e.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n\n  p.icon above e.icon\n  q.icon above e.icon\n\n  -- edge case\n  ensure norm(e.vec) > const.minSegmentLength\n\n  -- labeling\n  ensure disjoint(p.text, e.icon) in label\n  ensure disjoint(q.text, e.icon) in label\n}\n\nforall Segment e; Plane p {\n  e.icon above p.icon\n}\n\nforall Linelike s, t\nwhere EqualLength(s, t) {\n  ensure vdist(s.icon.start, s.icon.end) == vdist(t.icon.start, t.icon.end)\n}\n\n--TODO eventually this should also provide an equal length marker since it is bisecting the segment\nforall Segment s\nwhere s := PerpendicularBisector(s2, p)\nwith Segment s2; Point p {\n  override s.icon = Line {\n    start : p.icon.center\n    end : midpoint(s2.icon.start, s2.icon.end)\n    strokeColor : s.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\n\n  s.mark = Path {\n    d : pathFromPoints(\"open\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\n}\n\nforall Segment s\nwhere s := PerpendicularBisectorLabelPts(s2, p1, p2)\nwith Segment s2; Point p1, p2 {\n  override p2.vec = midpoint(s2.icon.start, s2.icon.end)\n  override s.icon = Line {\n    start : p1.icon.center\n    end : p2.vec\n    strokeColor : s.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\n\n  s.mark = Path {\n    d : pathFromPoints(\"open\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\n}\n\nforall Linelike s, t \nwhere EqualLengthMarker(s, t) as e {\n  e.equivGroup = match_id\n  override s.tick = Path {\n    d : ticksOnLine(s.icon.start, s.icon.end, 15., e.equivGroup, 10.)\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor: Colors.none\n  }\n  override t.tick = Path {\n    d : ticksOnLine(t.icon.start, t.icon.end, 15., e.equivGroup, 10.)\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor: Colors.none\n  }\n  s.tick above s.icon\n  t.tick above t.icon\n}\n\n-- HACK: set transitive equal marks to have the same amount of ticks. This will not decrement subsequent matches of `EqualLength`, so only use this when there are _only_ transitive equal marks in a diagram\nforall Linelike s, t, u\nwhere EqualLengthMarker(s, t) as e1; EqualLengthMarker(t, u) as e2 {\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\n  -- NOTE: since we cannot handle transitive predicates and don't allow recursive expressions, we override the shape properties so the tick counts are the same\n  override s.tick.d = ticksOnLine(s.icon.start, s.icon.end, 15., minEquivGroup, 10.) \n  override u.tick.d = ticksOnLine(u.icon.start, u.icon.end, 15., minEquivGroup, 10.) \n  override t.tick.d = ticksOnLine(t.icon.start, t.icon.end, 15., minEquivGroup, 10.) \n}\n\n--Angle\nforall Angle theta\nwhere theta := InteriorAngle(p, q, r)\nwith Point p; Point q; Point r {\n  theta.p = p.vec\n  theta.q = q.vec\n  theta.r = r.vec\n  theta.color = #000\n  theta.side1 = Line {\n    start : p.icon.center\n    end : q.icon.center\n    strokeColor : theta.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  theta.side2 = Line {\n    start : q.icon.center\n    end : r.icon.center\n    strokeColor : theta.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  \n  theta.radius = const.thetaRadius\n  -- encourage the angle to be bigger than 10\n  angle = angleBetween(theta.q - theta.p, theta.q - theta.r) \n  ensure angle > 10/180 * MathPI()\n  theta.side1 below p.icon, q.icon\n  theta.side2 below q.icon, r.icon\n}\n\nforall Angle theta\nwhere theta := InteriorAngle(p, q, r); theta has label\nwith Point p; Point q; Point r {\n  padding = const.textPadding + const.pointRadius + theta.text.width\n  labelDir = normalize((p.vec - q.vec) + (r.vec - q.vec))\n  theta.text = Equation {\n    string : theta.label\n    fillColor : Colors.black\n    fontSize : const.fontSize\n    center: q.vec + labelDir*padding\n  }\n}\n\nforall Angle a, b\nwhere EqualAngleMarker(a, b) as e {\n  e.equivGroup = match_id\n  --find points from p->q, then q->r for each vector. draw vectors for each\n  a.start = ptOnLine(a.q, a.p, a.radius)\n  a.end = ptOnLine(a.q, a.r, a.radius)\n  a.sweep = arcSweepFlag(a.q, a.start, a.end)\n  a.spacing = 10\n\n  b.start = ptOnLine(b.q, b.p, b.radius)\n  b.end = ptOnLine(b.q, b.r, b.radius)\n  b.sweep = arcSweepFlag(b.q, b.start, b.end)\n  b.spacing = 10\n\n  override a.mark = Path {\n    d : repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), e.equivGroup, a.spacing, a.sweep)\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor: Colors.none\n }\n  override b.mark = Path {\n    d : repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), e.equivGroup, b.spacing, b.sweep)\n    strokeWidth : 2.0\n    strokeColor : Colors.black\n    fillColor: Colors.none\n }\n}\n\nforall Angle a, b, c\nwhere EqualAngleMarker(a, b) as e1; EqualAngleMarker(b, c) as e2 {\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\n  override a.mark.d = repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), minEquivGroup, a.spacing, a.sweep)\n  override b.mark.d = repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), minEquivGroup, b.spacing, b.sweep)\n  override c.mark.d = repeatedArcs(c.start, c.end, c.p, c.r, (c.radius, c.radius), minEquivGroup, c.spacing, c.sweep)\n}\n\nforall Angle a, b\nwhere EqualAngle(a, b) {\n  -- make sure angle a is equal to angle b\n  -- HACK: increase the magnitude of angles\n  weight = 100\n  angleA = angleBetween(a.p - a.q, a.r - a.q) * weight\n  angleB = angleBetween(b.p - b.q, b.r - b.q) * weight\n  ensure angleA == angleB \n}\n\nforall Angle a\nwhere RightUnmarked(a) {\n  -- ensure perpendicular(a.p, a.q, a.r)\n  vec2 u = a.p - a.q\n  vec2 v = a.r - a.q\n  ensure dot(u, v) == 0\n}\n\nforall Angle a\nwhere RightMarked(a) {\n  --render half square path of size a.radius\n  markSize = 10\n  a.mark = Path {\n    d : pathFromPoints(\"open\", [ptOnLine(a.q, a.p, markSize), innerPointOffset(a.q, a.p, a.r, markSize), ptOnLine(a.q, a.r, markSize)])\n    strokeWidth : 2.0\n    strokeColor : #000\n    fillColor : Colors.none\n  }\n  vec2 u = a.p - a.q\n  vec2 v = a.r - a.q\n  ensure dot(u, v) == 0\n}\n\nforall Angle a\nwhere Acute(a) {\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), 0, MathPI()/2)\n}\n\nforall Angle a\nwhere Obtuse(a) {\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), MathPI()/2, MathPI())\n}\n\nforall Triangle t; Plane P \nwhere t := Triangle(p, q, r)\nwith Point p; Point q; Point r {\n  t.PQ above P.icon\n  t.QR above P.icon\n  t.RP above P.icon\n  t.icon above P.icon\n}\n\nforall Triangle t\nwhere t := Triangle(p, q, r)\nwith Point p; Point q; Point r {\n  t.color = Colors.black\n  t.PQ = Line {\n    start : p.icon.center\n    end : q.icon.center\n    strokeColor : t.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  t.QR = Line {\n    start : q.icon.center\n    end : r.icon.center\n    strokeColor : t.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  t.RP = Line {\n    start : r.icon.center\n    end : p.icon.center\n    strokeColor : t.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  t.icon = Path {\n    d: pathFromPoints(\"closed\", [p.vec, q.vec, r.vec])\n    fillColor: none()\n    strokeColor: none()\n  }\n  ensure norm(p.vec - q.vec) > const.minSegmentLength\n  ensure norm(q.vec - r.vec) > const.minSegmentLength\n  ensure norm(r.vec - p.vec) > const.minSegmentLength\n  ensure disjoint(t.icon, p.text) in label\n  ensure disjoint(t.icon, q.text) in label\n  ensure disjoint(t.icon, r.text) in label\n\n  t.PQ below p.icon\n  t.PQ below q.icon\n  t.QR below q.icon\n  t.QR below r.icon\n  t.RP below r.icon\n  t.RP below p.icon\n}\n\nforall Point p\nwith Triangle T; Point t1, t2, t3\nwhere T := Triangle(t1, t2, t3); Incenter(p, T) {\n  override p.vec = incenter(t1.vec, t2.vec, t3.vec)\n  clr = setOpacity(Colors.darkpurple, 0.6)\n  T.incenterIcon = Circle {\n    center : p.vec\n    r : inradius(t1.vec, t2.vec, t3.vec) - const.strokeWidth\n    strokeWidth : const.strokeWidth\n    strokeColor : clr\n    strokeStyle: \"dashed\"\n    fillColor : Colors.none\n  }\n  T.incenterIcon below t1.icon\n  T.incenterIcon below t2.icon\n  T.incenterIcon below t3.icon\n}\n\nforall Point p\nwhere Circumcenter(p, T)\nwith Triangle T {\n  clr = Colors.darkpurple\n  override p.icon = Circle {\n    center : p.vec\n    r : const.pointRadius\n    strokeWidth : const.strokeWidth\n    strokeColor : clr\n    fillColor : clr\n  }\n  p.icon above T.PQ\n  p.icon above T.QR\n  p.icon above T.RP\n  T.icon = Circle {\n    center : p.vec\n    r : ?\n    strokeWidth : const.strokeWidth\n    strokeColor : clr\n    fillColor : Colors.none\n    strokeStyle: \"dashed\"\n  }\n  ensure norm(T.PQ.start - p.vec) == T.icon.r\n  ensure norm(T.QR.start - p.vec) == T.icon.r\n  ensure norm(T.RP.start - p.vec) == T.icon.r\n  encourage repelPt(const.repelWeight, T.PQ.start, T.QR.start)\n  encourage repelPt(const.repelWeight, T.QR.start, T.RP.start)\n}\n\nforall Point p\nwhere Centroid(p, T)\nwith Triangle T {\n  clr = setOpacity(Colors.darkpurple, 0.6)\n  override p.vec = vmul(1/3, T.PQ.start + T.QR.start + T.RP.start)\n  override p.icon = Circle {\n    center : p.vec\n    r : const.pointRadius\n    strokeWidth : const.strokeWidth\n    strokeColor : clr\n    fillColor : clr\n  }\n  override T.icon = Line {\n    start : T.PQ.start\n    end : midpoint(T.QR.start, T.QR.end)\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  override T.line2 = Line {\n    start : T.QR.start\n    end : midpoint(T.RP.start, T.RP.end)\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  override T.icon3 = Line {\n    start : T.RP.start\n    end : midpoint(T.PQ.start, T.PQ.end)\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n}\n\nforall Point p\nwhere Orthocenter(p, T)\nwith Triangle T {\n  clr = setOpacity(Colors.darkpurple, 0.6)\n  T.icon = Line {\n    start : (?, ?)\n    end : p.vec\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  T.icon2 = Line {\n    start : (?, ?)\n    end : p.vec\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  T.icon3 = Line {\n    start : (?, ?)\n    end : p.vec\n    strokeColor : clr\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n\n  -- TODO make it so that predicates can reference other predicates. 3/4 of these are copy-pasted from the Collinear predicate\n  ensure collinear(T.PQ.start, T.icon.start, T.PQ.end)\n  ensure collinear(T.QR.start, T.icon2.start, T.QR.end)  \n  ensure collinear(T.RP.start, T.icon3.start, T.RP.end)\n\n  ensure perpendicular(T.PQ.start, T.icon.start, p.vec)\n  ensure perpendicular(T.QR.start, T.icon2.start, p.vec)  \n  ensure perpendicular(T.RP.start, T.icon3.start, p.vec)\n\n  encourage repelPt(const.repelWeight, T.PQ.start, T.icon.start)\n  encourage repelPt(const.repelWeight, T.PQ.end, T.icon.start)\n\n  encourage repelPt(const.repelWeight, T.QR.start, T.icon2.start)\n  encourage repelPt(const.repelWeight, T.QR.end, T.icon2.start)\n\n  encourage repelPt(const.repelWeight, T.RP.start, T.icon3.start)\n  encourage repelPt(const.repelWeight, T.RP.end, T.icon3.start)\n\n}\n\n--Rectangle\n-- -- Should the rectangle be constructed from the points, or vice versa?\nforall Rectangle R\nwhere R := Rectangle(p, q, r, s)\nwith Point p; Point q; Point r; Point s {\n  override R.color = Colors.none\n  override R.icon = Path {\n      d : pathFromPoints(\"closed\", [p.icon.center, q.icon.center, r.icon.center, s.icon.center])\n      strokeWidth : const.strokeWidth\n      fillColor : R.color\n      strokeColor : Colors.black\n    }\n  ensure vdist(p.icon.center, q.icon.center) == vdist(r.icon.center, s.icon.center)\n  ensure vdist(p.icon.center, s.icon.center) == vdist(q.icon.center, r.icon.center)\n\n  ensure perpendicular(p.icon.center, q.icon.center, r.icon.center)\n  ensure perpendicular(q.icon.center, s.icon.center, r.icon.center)\n\n  -- R.icon above P.icon\n}\n\nforall Quadrilateral Q\nwhere Q := Quadrilateral(p, q, r, s)\nwith Point p; Point q; Point r; Point s {\n  Q.p = p.icon.center\n  Q.q = q.icon.center\n  Q.r = r.icon.center\n  Q.s = s.icon.center\n\n  override Q.color = Colors.black\n  Q.side1 = Line {\n    start : Q.p\n    end : Q.q\n    strokeColor : Q.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  Q.side2 = Line {\n    start : Q.r\n    end : Q.q\n    strokeColor : Q.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  Q.side3 = Line {\n    start : Q.s\n    end : Q.r\n    strokeColor : Q.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  Q.side4 = Line {\n    start : Q.p\n    end : Q.s\n    strokeColor : Q.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }  \n  Q.labelContainer = Path {\n    d: pathFromPoints(\"closed\", [Q.p, Q.q, Q.r, Q.s])\n    fillColor: none()\n  }\n  -- TODO: check if the points actually have labels\n  ensure disjoint(p.text, Q.labelContainer) in label\n  ensure disjoint(q.text, Q.labelContainer) in label\n  ensure disjoint(r.text, Q.labelContainer) in label\n  ensure disjoint(s.text, Q.labelContainer) in label\n  -- ensure all sides are visible\n  ensure norm(Q.p - Q.q) > const.minSegmentLength\n  ensure norm(Q.q - Q.r) > const.minSegmentLength\n  ensure norm(Q.r - Q.s) > const.minSegmentLength\n  ensure norm(Q.s - Q.p) > const.minSegmentLength\n  ensure norm(Q.r - Q.p) > const.minSegmentLength\n  ensure norm(Q.s - Q.q) > const.minSegmentLength\n}\n\n--FUNCTIONS\nforall Segment s\nwith Triangle T; Point p, q, r, a, b\nwhere s := MidSegment(T, a, b); T := Triangle(p, q, r) {\n  override a.vec = midpoint(q.vec, r.vec)\n  override b.vec = midpoint(r.vec, p.vec)\n  override s.icon = Line {\n    start : a.vec\n    end : b.vec\n    strokeColor : s.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n}\n\nforall Point p\nwhere p := Midpoint(l)\nwith Linelike l {\n  override p.vec = midpoint(l.icon.start, l.icon.end)\n}\n\nforall Point p\nwhere Midpoint(l, p)\nwith Linelike l {\n  override p.vec = midpoint(l.icon.start, l.icon.end)\n}\n\nforall Point p\nwhere Midpoint(l, p); p has label\nwith Linelike l {\n  override p.vec = midpoint(l.icon.start, l.icon.end)\n  ensure disjoint(p.text, l.icon) in label\n}\n\n-- TODO sometimes bisector becomes a scaled version of either side length PQ or QR of angle PQR\nforall Linelike s\nwhere AngleBisector(a, s)\nwith Angle a; Point p {\n  weight = 100\n  angleA = angleBetween(a.p - a.q, s.end - a.q) * weight\n  angleB = angleBetween(s.end - a.q, a.r - a.q) * weight\n  bigAngle = angleBetween(a.q - a.p, a.q - a.r) * weight\n  ensure angleA == angleB \n  -- HACK: make sure the angle itself is not zero\n  ensure bigAngle > 15/180 * MathPI() * weight \n  -- HACK: make sure the bisector end point is between angle end points. Might be too specific\n  ensure inRange(s.end[0], a.p[0], a.r[0])\n  ensure inRange(s.end[1], a.p[1], a.r[1])\n}\n\nforall Circle c {\n  c.radius = const.circleRadius\n  c.vec = (?, ?)\n\n  c.icon = Circle {\n    center : c.vec\n    r : c.radius\n    strokeWidth : const.strokeWidth\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n}\n\nforall Circle c\nwhere c := CircleR(p, q)\nwith Point p, q {\n  override c.radius = vdist(p.vec, q.vec)\n  override c.vec = p.icon.center\n  override c.icon = Circle {\n    center : c.vec\n    r : c.radius\n    strokeWidth : const.strokeWidth\n    strokeColor : Colors.black\n    fillColor : Colors.none\n  }\n}\n\n-- TODO this can be reimplemented when issue #621 is resolved\n-- Circle c\n-- where c := CircleD(p, q)\n-- with Point p, q {\n--   override c.radius = vdist(p.vec, q.vec) / 2\n-- }\n\nforall Segment s\nwhere s := Chord(c, p, q)\nwith Circle c; Point p, q {\n  override s.vec = q.vec - p.vec\n  override s.icon = Line {\n    start : p.icon.center\n    end : q.icon.center\n    strokeColor : s.color\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n\n  p.icon above c.icon\n  q.icon above c.icon\n  ensure norm(p.vec - c.vec) == c.radius\n  ensure norm(q.vec - c.vec) == c.radius\n  ensure norm(q.vec - p.vec) > const.minSegmentLength\n}\n\nforall Segment s\nwhere s := Chord(c, p, q); p has label; q has label \nwith Circle c; Point p, q {\n  ensure disjoint(c.icon, p.text) in label\n  ensure disjoint(c.icon, q.text) in label\n}\n\nforall Segment s\nwhere s := Radius(c, p)\nwith Circle c; Point p {\n  override s.vec = p.vec - c.vec\n  override s.icon = Line {\n    start : c.vec\n    end : p.icon.center\n    strokeColor : Colors.black\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n  }\n  p.icon above c.icon\n  ensure norm(c.vec - p.vec) == c.radius\n}\n\nforall Segment s\nwhere s := Radius(c, p); p has label \nwith Circle c; Point p {\n  ensure disjoint(p.text, s.icon) in label\n}\n\nforall Segment s\nwhere s := Radius(c, p); p has label\nwith Circle c; Point p {\n  ensure disjoint(p.text, c.icon) in label\n}\n\nforall Segment s\nwhere s := Diameter(c, p, q)\nwith Circle c; Point p, q {\n  override s.vec = q.vec - p.vec\n  override s.icon = Line {\n    start : p.icon.center\n    end : q.icon.center\n    strokeWidth : const.strokeWidth\n    style : \"solid\"\n    strokeColor : Colors.black\n  }\n\n  p.icon above c.icon\n  q.icon above c.icon\n  ensure norm(midpoint(p.vec, q.vec) - c.icon.center) == 0\n  ensure c.icon.r * 2 == norm(s.vec)\n}\n\nforall Point p\nwhere OnCircle(c, p)\nwith Circle c {\n  ensure norm(c.vec - p.vec) == c.radius\n}\n\nforall Point p\nwhere OnCircle(c, p); p has label\nwith Circle c {\n  ensure disjoint(p.text, c.icon) in label\n}\n\nforall Point p\nwhere CircleCenter(c, p)\nwith Circle c {\n  ensure norm(p.vec - c.vec) == 0\n}\n\nforall Shape s1, s2\nwhere s1 has label; s2 has label {\n  encourage notTooClose(s1.text, s2.text)\n}","sampleSubstance":{"prog":"-- Defining the points\nPoint A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q\n\n-- Defining the Line, Segment and Ray\nLine lineAB := Line(A, B)\nSegment segmentBC := Segment(B, C)\nRay rayCD := Ray(C, D)\n\n-- Defining a Point as Midpoint of a Line\nPoint AB := Midpoint(lineAB)\n\n-- Defining the Angles\nAngle angleABC := InteriorAngle(A, B, C)\nAngle angleBCD := InteriorAngle(B, C, D)\n\n-- Defining Polygons/Shapes\nTriangle triangleABC := Triangle(A, B, C)\nRectangle rectangleEFGH := Rectangle(E, F, G, H)\nQuadrilateral quadrilateralIJKL := Quadrilateral(I, J, K, L)\nCircle circleMN := CircleR(M, N)\n\n-- Defining the Plane\nPlane V\n\n-- Using the functions\nRay rayBA := Bisector(angleABC)\nSegment segmentEF := PerpendicularBisector(segmentBC, E)\nSegment segmentFG := PerpendicularBisectorLabelPts(segmentBC, F, G)\nSegment segmentKL := MidSegment(triangleABC, K, L)\nSegment segmentMN := Radius(circleMN, N)\nSegment segmentNO := Chord(circleMN, N, O)\nSegment segmentMO := Diameter(circleMN, O, P)\n\n-- Using the predicates\nOn(A, lineAB)\nIn(A, V)\nMidpoint(lineAB, AB)\nCollinear(A, B, C)\nParallelMarker1(lineAB, rayCD)\nEqualLengthMarker(segmentBC, segmentEF)\nEqualLength(segmentBC, segmentEF)\nParallel(lineAB, rayCD)\nAcute(angleABC)\nObtuse(angleBCD)\nRightMarked(angleABC)\nRightUnmarked(angleBCD)\n-- AngleBisector(angleABC, rayBA)\nEqualAngleMarker(angleABC, angleBCD)\nEqualAngle(angleABC, angleBCD)\nParallelogram(quadrilateralIJKL)\nOnCircle(circleMN, N)\n-- CircleCenter(circleMN, M)\n-- Incenter(A, triangleABC)\n-- Orthocenter(B, triangleABC)\n-- Centroid(C, triangleABC)\n-- Circumcenter(D, triangleABC)\n\nAutoLabel A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, V, AB\n","name":"Complete Geometry domain"}},"output":"\nPoint A, B, C, D\nSegment AB := Segment(A, B)\nSegment BC := Segment(B, C)\nSegment CD := Segment(C, D)\nSegment BD := Segment(B, D)\nMidpoint(AB, B)\nCollinear(A, B, C)\nAngle angleABC := InteriorAngle(A, B, C)\nAngle angleCBD := InteriorAngle(C, B, D)\nAcute(angleABC)\nObtuse(angleCBD)\n","inferenceTime":8915,"penroseError":{"errorType":"StyleError","tag":"StyleErrorList","errors":[{"tag":"CyclicAssignmentError","cycles":[[{"id":"`B`.vec","src":{"start":{"line":752,"col":19},"end":{"line":752,"col":53}}},{"id":"`B`.icon.center","src":{"start":{"line":72,"col":12},"end":{"line":72,"col":17}}},{"id":"`AB`.icon.end","src":{"start":{"line":242,"col":10},"end":{"line":242,"col":23}}},{"id":"`B`.vec","src":{"start":{"line":752,"col":19},"end":{"line":752,"col":53}}}]]}]}}